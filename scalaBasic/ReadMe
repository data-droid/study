# 빅데이터 - 스칼라, 스파크로 시작하기
* 스파크는 인메모리 기반 처리로 하둡 맵리듀스에 비해 100배 빠른 속도를 제공하며 ML, Graph 분석 등 다양한 컴포넌트를 가짐.
* 스파크는 스칼라로 작성되어 자바보다 짧은 코드로 표현 가능하며, JVM에서 동작하기 때문에 기존 자바 라이브러리를 모두 사용 가능.

## Scala
* 객체 지향 언어의 특징과 함수형 언어의 특징을 가지는 다중 패러다임 프로그래밍 언어.

### 특징
* JVML
    * JVM 위에서 동작하는 언어 (kotlin, Groovy 등..)
    * 자바의 모든 라이브러리를 사용가능함
    * 스칼라 컴파일러를 통해 바이트 코드로 변환하고, 바이트 코드는 JVM상에서 자바와 동일하게 실행됨.
* 함수형 언어
    * 자바에 비해 코드길이가 간결함.
    * getter, setter, 생성자를 생략하고, 표현식을 간소함.
* 바이트 코드 최적화
    * 자바보다 20% 속도가 빠름.
* 동시성에 강함
    * Immutable 변수를 많이 가지고 있어, 속성을 변경 불가능하게 하고, 순수 함수를 사용하여 병렬 프로그래밍에 강점이 있음.
    
### 함수형 프로그래밍
* 함수형 언어 
    * 함수형 프로그래밍의 패러다임을 따르는 언어
    * C#, Java 같은 객체지향언어에서도 람다 함수의 도입을 통해 함수형 지원하려고 함.
* 함수형 프로그래밍
    * 자료 처리를 수학적 함수의 계산으로 취급하고 상태 변화와 가변 데이터를 피함.
    * 순수 함수와 보조 함수의 조합으로 조건문, 반복문을 제거하여 복잡성을 낮춤.
    * 변수 사용을 줄여 상태 변경을 피함.
* 순수 함수(Pure Function)
    * 함수의 실행이 외부에 영향을 끼치지 않는 함수.(병렬 계산이 가능!)
* 익명 함수(Anonymous Function)
    * 함수 선언 없이 익명 함수를 생성하여 코드 길이를 줄임.
    * Arrays.asList(1,2,3).stream().reduce((a,b)->a-b).get()
* 고차 함수(Higher-Order Function)
    * 함수를 인수로 취급하는 함수.
    * 함수를 입력 파라미터나 출력 값으로 처리.
    * Collection.sort(new ArrayList<Integer>(), (x,y) -> x>=y? -1:1);
    
 ### 객체
* 기본 자료형, 함수, 클래스 모두 객체로 취급.
* 비교 연산은 ==, != 으로 모두 가능!
 
 ### 자료형
 * 자바와 동일하며 자바의 Primitive Type은 존재 하지 않으며 모든 것이 클래스.
 * 컴파일 시점에 자바 자료형으로 변함.
 * 숫자형, 논리형, 문자형이 있으며, 선언하지 않고 사용할 수 있으며, 정수형은 Int, 실수는 Double로 선언 됨.
 * 기본 자료형
    * Byte, Short, Int, Long, Float, Double, Char, Boolean
 * 참조 자료형
    * String, Unit, NULL, Nothing, Any, AnyVal, AnyRef
 * 숫자형
    * 정수형 : Byte, Short, Int, Long
    * 실수형 : Float, Double
 * 캐스팅
    * 업캐스팅(사이즈가 더 큰걸로)은 자동으로 됨. 
    * 다운캐스팅은 명시해야함.
 * 접두어 처리
    * 접두어를 붙여 컴파일시점에 문자열 변환 처리 가능
    * s
        * ${변수명{을 이용하여 문자열 내 변수를 값으로 치환. 연산도 가능.
    * f
        * 문자열 포맷팅. printf()와 같은 방식
    * raw
        * 특수문자를 처리하지 않고 원본 문자로 인식.

### 변수
* var : 가변 변수 ( 재할당 가능 ! )
* val : 불변 변수 ( 재할당 불가능 ! ), 동시 처리!!
   
### 함수
* 특징
    * def 로 선언
    * 리턴문과 리턴 타입 생략이 가능함.
    * 매개변수의 파라미터 타입은 생략 불가!
    * 리턴값이 없는 경우 Unit
    * 매개변수는 immutable 변수임! 수정불가!
    * 리턴 타입이 Unit이 아닌 경우 마지막 값을 리턴!
* 축약형
    * 1라인으로 처리 가능한 경우 중괄호 없이 선언 가능!
    * def printUpper(message:String):Unit = println(message.toUpperCase())
    * def printLower(message:String) = println(message.toLowerCase())
* 파라미터 default
    * def add(x: Int, y: Int=10): Unit = println(x+y)
* 가변 길이 파라미터
    * \*을 이용하면 Seq형으로 변환되어 입력
    * def sum(num:Int\*) = num.reduce( _ + _ )
* 변수에 함수 결과 할당
    * val, var는 호출할 때마다 같은 값 반환
    * def는 호출할 때마다 다른 값 반환
    * val random1 = Math.random()
    * var random2 = Math.random()
    * def random3 = Math.random()
* 함수 내 다른 함수를 선언할 수 있음!

#### 람다 함수
* \_를 이용하여 묵시적인 파라미터 지정가능.
* def exec(f: (Int,Int) => Int, x:Int, y:Int) = f(x,y)
* exec((x:Int, y:Int) => x+y, 2, 3)
* exec((x,y)=>x+y, 2,3)
* exec(_ + _ , 3, 1)

#### 커링
* 여러 개 인수 목록을 여러 개의 괄호로 정의
* 정해진 파라미터 수보다 적은 인수로 호출시 리턴 값은 나머지 파라미터를 받는 함수.
* def modN(n:Int, x:Int) = ((x%n)==0)
* def modN(n:Int)(x:Int) = ((x%n)==0)
    * n값을 미리 바인딩 하는 다른 함수로 선언 가능. 
    * 다른 함수의 파라미터로 전달 가능.
    
#### 클로저
* 내부에 참조되는 인수에 대한 바인딩.

#### 타입
* 타입(T)를 이용해 클래스와 함수를 제너릭하게 생성 가능.

#### 클래스
* 멤버 변수 선언 및 생략 가능
    * class Person(name:String, age:Int) //선언
    * val p = new Person("Jay", 29) // 생성
    * class A // 멤버변수 생략 가능
* 클래스 멤버 변수
    * 가변 변수
        * 컴파일러가 클래스 내부에 자동으로 getter, setter 메소드 생성
        * 가변 변수를 읽고, 쓰기 가능
    * 불변 변수
        * 컴파일러가 getter만 생성.
        * 불변 변수는 읽기만 가능
    * 그 외 변수
        * getter, setter가 생성되지 않아 클래스 내에서만 사용가능.
    * default
        * 기본, 변수, 상수 모두 기본값 설정 가능.
* 클래스의 메소드
    * 함수와 마찬가지로 def로 선언
    * override 선언자를 통해 오버라이드 가능.
    * new 를 이용하여 클래스 생성시 오버라이드하여 매소스 재정의 가능.
* 생성자
    * 생성자가 따로 존재하지 않음.
* 상속과 추상 클래스
    * extends
        * 일반 클래스, 추상클래스 모두 상속 가능.
    * abstract
        * 매개변수를 가질 수 있음.
        * 메소드 선언만 하고 자식 클래스에서 구현 가능.
        * 기본 메소드를 구현 가능.
* Sealed Class
    * 하위 타입이 모두 한파일에 있어야 함.
    * 관련 클래스를 한파일에 모두 입력하게 강제할 수 있어 관리 효율성이 높아짐.
    * sealed를 이용하고 trait도 봉인 가능
    * file1.scala
        * sealed abstract class Furniture
        * case class Couch() extends Furniture
        * case class Chair() extends Furniture
    * file2.scala
        * case class Desk() extends Furniture
        * sealed class를 생성하고 다른 파일에서 클래스 선언시 illegal inheritance from sealed class Furniture 오류 발생!
* case Class       
    * 일반 클래스와 달리 인스턴스를 생성할 때 new를 사용하지 않음.
    * 불변 데이터
        * 멤버변수는 기본적으로 불변 변수로 선언.
    * 패턴 매칭
        * 자바의 case와 유사하지만 더 강력함.
    * 데이터 비교
        * 케이스 클래스의 비교는 참조값을 이용하지 않고, 멤버변수의 데이터를 이용해 처리.
    * 초기화가 간단함
        * new를 이용하지 않고 초기화 가능.
        * var p = Person("A", 10)
    * 자동 코드 생성
        * toString, hashCode, equals를 자동으로 생성.
        * 새로운 복제 객체를 리턴하는 copy() 메서드를 자동으로 생성.
        
